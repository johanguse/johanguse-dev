---
title: 'Using React useState to store multiple values'
date: '2024-04-09'
lastmod: '2024-04-09'
tags: ['react', 'frontend']
draft: false
summary: 'Learn how we can store multiple values in single state using useState hook in functional component.'
images: ['/static/images/react-usestate-multiple-values.jpg']
authors: ['default']
---

Recently, I encountered a common React pattern that could definitely be improved. The codebase had two buttons with loading states, and the previous developer created separate `useState` hooks for each button's loading state. While this works, it violates the DRY (Don't Repeat Yourself) principle and creates unnecessary complexity.

Let me show you the original approach and then demonstrate a cleaner solution:

```jsx
const [isGithubLoading, setIsGithubLoading] = useState<boolean>(false)
const [isGoogleLoading, setIsGoogleLoading] = useState<boolean>(false)

<button onClick={() => setIsGithubLoading(true)}>
  {isGithubLoading ? <p>Loading...</p> : <p>Github</p>}
</button>

<button onClick={() => setIsGoogleLoading(true)}>
  {isGoogleLoading ? <p>Loading...</p> : <p>Google</p>}
</button>
```

This approach works, but it's not ideal. Having separate states for each button violates the [DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) and creates unnecessary complexity. Instead, we can consolidate these into a single state object, making our code more maintainable and easier to scale.

```jsx
// Define the types for the loading states
interface LoadingState {
  google: boolean;
  github: boolean;
}

// Initialize the default values for loading states
const initialLoadingValues: LoadingState = {
  google: false,
  github: false,
};

// Create a custom hook to handle loading state
function useLoading(initialState: LoadingState) {
  const [isLoading, setIsLoading] = useState<LoadingState>(initialState);

  // Generic function to handle the loading state for each provider
  function handleLoading(provider: keyof LoadingState) {
    // Enable the spinner
    setIsLoading(prevState => ({
      ...prevState,
      [provider]: true,
    }));
    
    // Simulate async operation (replace with your actual API call)
    setTimeout(() => {
      setIsLoading(prevState => ({
        ...prevState,
        [provider]: false,
      }));
    }, 1000);
  }

  return { isLoading, handleLoading };
}

// Your functional component that uses the hook
export default function LoadingButtons() {
  const { isLoading, handleLoading } = useLoading(initialLoadingValues);

  return (
    <>
      <button onClick={() => handleLoading('github')}>
        {isLoading.github ? <p>Loading...</p> : <p>Github</p>}
      </button>

      <button onClick={() => handleLoading('google')}>
        {isLoading.google ? <p>Loading...</p> : <p>Google</p>}
      </button>
    </>
  );
}
```

For a simpler approach without a custom hook, you can directly manage the state in your component:

```jsx
const initialLoadingValues = {
  google: false,
  github: false,
}

const [isLoading, setIsLoading] = useState(initialLoadingValues)

function handleLoading(provider: 'google' | 'github') {
  // Enable the spinner
  setIsLoading(prevState => ({
    ...prevState,
    [provider]: true,
  }))
  
  // Simulate async operation (replace with your actual API call)
  setTimeout(() => {
    setIsLoading(prevState => ({
      ...prevState,
      [provider]: false,
    }))
  }, 1000)
}

// Using the handleLoading function
<button onClick={() => handleLoading('github')}>
  {isLoading.github ? <p>Loading...</p> : <p>Github</p>}
</button>

<button onClick={() => handleLoading('google')}>
  {isLoading.google ? <p>Loading...</p> : <p>Google</p>}
</button>
```

## Key Benefits

This approach offers several advantages:

1. **Reduced code duplication**: Instead of multiple `useState` hooks, we use a single state object
2. **Better scalability**: Adding new buttons or loading states is straightforward
3. **Improved maintainability**: Changes to the loading logic only need to be made in one place
4. **Type safety**: TypeScript interfaces ensure type safety and better IDE support

## Live Example

You can see this pattern in action: [Check out the working example](https://bit.ly/usestate-storing-multiple-values)

## Conclusion

By consolidating multiple related states into a single state object, we've created a more maintainable and scalable solution. This pattern is particularly useful when you have multiple similar states that can be grouped together. Remember, good code isn't just about functionalityâ€”it's about readability, maintainability, and following established patterns like the DRY principle.
